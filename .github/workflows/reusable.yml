# .github/workflows/reusable.yaml
name: Reusable Workflow

on:
  workflow_call:
    inputs:
      build_distro:
        required: true
        type: string
      build_os:
        required: true
        type: string
      test_distro:
        required: true
        type: string
      test_os:
        required: true
        type: string
      compiler:
        required: true
        type: string
      c_compiler:
        required: true
        type: string
      cpp_compiler:
        required: true
        type: string
      stdlib:
        required: true
        type: string
      preset:
        required: true
        type: string
      target:
        required: true
        type: string
      build_type:
        required: true
        type: string
      toolchain:
        type: string
      head_ref:
        required: true
        type: string
      base_ref:
        required: true
        type: string

jobs:
  build:
    runs-on: ${{ inputs.build_distro }}
    steps:
    - uses: actions/checkout@v4

    - name: "Install Clang 19"
      if: inputs.build_os == 'linux' && inputs.c_compiler == 'clang-19'
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y wget gnupg lsb-release
        wget https://apt.llvm.org/llvm.sh
        chmod +x llvm.sh
        sudo ./llvm.sh 19
        # Install libc++ and libc++abi for Clang 19
        sudo apt-get install -y libc++-19-dev libc++abi-19-dev
        sudo ln -sf /usr/bin/llvm-cov-19 /usr/local/bin/llvm-cov
        sudo ln -sf /usr/bin/llvm-profdata-19 /usr/local/bin/llvm-profdata
        sudo ln -sf /usr/bin/clang-19 /usr/local/bin/clang
        sudo ln -sf /usr/bin/clang++-19 /usr/local/bin/clang++
        sudo ln -sf /usr/bin/clang-format-19 /usr/local/bin/clang-format

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
      id: strings
      shell: bash
      run: |
        echo "build-output-dir=$(readlink -f '${{ github.workspace }}/../build')" >> "$GITHUB_OUTPUT"

    - name: Configure CMake
      shell: bash
      run: |
        # Configure
        cmake -B '${{ steps.strings.outputs.build-output-dir }}' -S '${{ github.workspace }}' \
        --preset=${{ inputs.preset }}_${{ inputs.build_os }}_${{ inputs.compiler }}_${{ inputs.stdlib }} \
        -DCMAKE_BUILD_TYPE=${{ inputs.build_type }}

        # Delete any coverage files created from CMake probing
        find '${{ github.workspace }}' \( -name '*.gcno' -o -name '*.gcda' \) -delete
        find '${{ steps.strings.outputs.build-output-dir }}' \( -name '*.gcno' -o -name '*.gcda' \) -delete

    - name: Register Compiler Problem Matcher
      shell: bash
      run: echo "::add-matcher::.github/problem_matchers/${{ inputs.compiler}}_problem_matcher.json"

    - name: Build
      shell: bash
      run: cmake --build '${{ steps.strings.outputs.build-output-dir }}' --target ${{ inputs.target }} --config ${{ inputs.build_type }} --parallel

    - name: Unregister Compiler Problem Matcher
      shell: bash
      run: echo "::remove-matcher owner=${{ inputs.compiler}}::"

    - name: Upload build dir
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.preset }}_${{ inputs.build_os }}_${{ inputs.compiler }}_${{ inputs.stdlib }}_${{ inputs.build_type }}
        path: '${{ steps.strings.outputs.build-output-dir }}'

  test:
    runs-on: ${{ inputs.test_distro }}
    needs: build
    steps:
    - uses: actions/checkout@v4

    - name: "Install Clang 19 Libcxx"
      if: inputs.test_os == 'linux' && inputs.stdlib == 'libcxx'
      shell: bash
      run: |
        # Install libc++ and libc++abi for Clang 19
        sudo apt-get install -y libc++-19-dev libc++abi-19-dev

    - name: Download build dir
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.preset }}_${{ inputs.build_os }}_${{ inputs.compiler }}_${{ inputs.stdlib }}_${{ inputs.build_type }}
        path: '${{ github.workspace }}/../build'

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
      id: strings
      shell: bash
      run: |
        if [[ "${{ inputs.preset }}" == "benchmark" ]]; then
          chmod +x '${{ github.workspace }}/../build/benchmark/${{ inputs.target }}'*
        else
          chmod +x '${{ github.workspace }}/../build/test/${{ inputs.target }}'*
        fi
        echo "build-output-dir=$(readlink -f '${{ github.workspace }}/../build')" >> "$GITHUB_OUTPUT"

    - name: Run coverage for Clang
      if: inputs.preset == 'coverage' && inputs.compiler == 'clang'
      uses: ./.github/actions/coverage_clang
      with:
        build-output-dir: ${{ steps.strings.outputs.build-output-dir }}
        GITHUB_TOKEN: ${{ secrets.github_token }}

    - name: Run coverage for GCC
      if: inputs.preset == 'coverage' && inputs.compiler == 'gcc'
      uses: ./.github/actions/coverage_gcc
      with:
        build-output-dir: ${{ steps.strings.outputs.build-output-dir }}
        GITHUB_TOKEN: ${{ secrets.github_token }}

    - name: Test
      if: inputs.preset != 'coverage'
      shell: bash
      run: ctest --test-dir ${{ steps.strings.outputs.build-output-dir }} --build-config ${{ inputs.build_type }} --output-on-failure --parallel

    - name: Cache benchmark json
      if: inputs.preset == 'benchmark'
      uses: actions/cache@v4
      with:
        path: '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result.json'
        key: benchmark_${{ inputs.test_os }}_${{ inputs.compiler }}_${{ inputs.stdlib }}_${{ inputs.build_type }}_${{ github.event.pull_request.head.ref }}

    - name: Rename current benchmark json
      if: inputs.preset == 'benchmark'
      shell: bash
      run: |
        mv '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result.json' '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result_new.json'

    - name: Fetch base_ref benchmark json
      if: inputs.preset == 'benchmark'
      id: base_ref_json
      uses: actions/cache@v4
      with:
        path: '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result.json'
        key: benchmark_${{ inputs.test_os }}_${{ inputs.compiler }}_${{ inputs.stdlib }}_${{ inputs.build_type }}_${{ github.event.pull_request.base.ref }}

    - name: Compare Benchmarks
      if: inputs.preset == 'benchmark' && steps.base_ref_json.outputs.cache-hit == 'true'
      shell: bash
      run: |
        python3 '${{ steps.strings.outputs.build-output-dir }}/_deps/benchmark-src/tools/compare.py' benchmarks \
          '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result.json' \
          '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result_new.json' \
          | tee '${{ steps.strings.outputs.build-output-dir }}/benchmark/comparison.txt'

    - name: Archive benchmark results
      if: inputs.preset == 'benchmark' && steps.base_ref_json.outputs.cache-hit == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: benchmark_${{ inputs.os }}_${{ inputs.compiler }}_${{ inputs.stdlib }}_json
        path: |
          '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result.json'
          '${{ steps.strings.outputs.build-output-dir }}/benchmark/benchmark_result_new.json'
          '${{ steps.strings.outputs.build-output-dir }}/benchmark/comparison.txt'
